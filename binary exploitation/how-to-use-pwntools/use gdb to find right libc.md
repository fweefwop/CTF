## ROP (Return Oriented Programming) o borrowed code chunks
The pieces of code that are invoked are known as gadgets.

This technique consists of chaining together different function calls using the **ret2libc** technique and using **pop,ret**.

In some processor architectures each instruction is a set of 32 bits. However, on Intel, instructions are variable in size and multiple instructions can shae a set of bits. for ie:  

**movl $0xe4ff, -0x(%ebp) â€”>** -> contains the 0xffe4 bytes which are also translated by: jmp *% esp

In this way you can execute some instructions that are not really eveen in the original program

**ROPgadget.py** helps us find values in binaries

This program is also used to create **payloads**. You can give him the libary from which you want to  get the ROPs and he will generate a python payload to which you give the address where said libary is and the payload is ready to be used as shellcode. In addition, as it uses system calls, it does not actually execute anything on the stack but only saves addresses of ROPs that will be executed through **ret**. To use this payload you have to call the payload through a **ret** instruction. 

## Addresses
To find the addresses, we look inside ```GDB```:     
**p system**     
**p exit**     
**x/500s $esp**  -> Look here for the string /bin /sh

Once we have these addresses, the **payload** should be:

"A"x numberOfPadding + 4(EBP: be 4'A's even beeter if the real EBP to avoid seg faults) + Management **system**(overwirte the EIP) + address **exit**(to the wxit system("/bin/sh"). this function will be called since the first 4 bytes of the stack are treated as the next address of the EIP to execute) + address of **/bin/sh** (it will be the parameter passsed to system)       

## Using addresses to find right libc

Get on https://libc.blukat.me/

![input addresses](
https://github.com/fweefwop/CTF-Bits-and-Bots/blob/master/binary%20exploitation/how-to-use-pwntools/Screenshot%20(5).png)


